package com.ming.leetCode;

/**
 * 198打家劫舍
 *  你是一个专业的小偷计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，
 *
 *  如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
 *给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。
 *  示例 1:
 * 输入: [1,2,3,1]
 * 输出: 4
 * 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
 *      偷窃到的最高金额 = 1 + 3 = 4 。
 *
 *
 * 示例 2:
 * 输入: [2,7,9,3,1]
 * 输出: 12
 * 解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
 *      偷窃到的最高金额 = 2 + 9 + 1 = 12 。
 * 示例 3:
 * 输入: [3,2,3,4]
 *  输出: 7
 *  解释: 偷窃 1 号房屋 (金额 = 3) ，然后偷窃 4 号房屋 (金额 = 4)。
 *       偷窃到的最高金额 = 3 + 4 = 7 。
 * @Author ming
 * @time 2020/2/21 19:35
 */
public class Solution198 {

    /**
     * 方法 ： 动态规划
     *  算法：
     *   考虑所有可能的抢劫方案过于困难。一个自然而然的想法是首先从最简单的情况开始。
     *   记： f(k) = 从前面k个房屋中抢到的最大数额， Ai = 第i个房间的钱数
     *
     *   首先 看 n= 1的情况 显然 f(1) = A1
     *   再看 n= 2情况， f(2) = max(A1, A2)
     *   对于 n = 3,有两个选项：
     *      1.抢第三个房子，将数额与第一个房子相加
     *      2. 不抢第三个房子，保持现有的最大数额
     *   显然，你想选择数额更大的选项。于是，可以总结出公式
     *   f(k) = max(f(k-2) + Ak , f(k - 1));
     *   就是 比较你 前面k-2 个房子抢到钱 加上 第k个钱，跟 k-1 个时抢到钱 做比较
     *
     *   因此需要需要记录每一步前两个最大值
     *
     *   举例
     *   数组
     *   【3 ，2 ，3， 4】
     *
     *        pm = 0; cm=0;
     *   k=1  【3】
     *          tmp = cm;
     *         cm = max(pm + 3,cm) = max(0+3,0)=3
     *         pm = temp = 0;
     *
     *
     *   k=2    【3, 2】
     *          tmp = cm = 3;
     *          cm = max(pm + 2, cm) = max(0+3,3) = 3
     *          pm = tmp = 3;
     *
     *   k=3   【3 ，2, 3】
     *          tmp = cm = 3
     *          cm = max(pm + 3, cm) = max(3+3, 3) = 6
     *          pm = tmp = 3
     *
     *   k=4  【3,2,3,4】
     *          tmp = cm = 6
     *          cm = max(pm + 3, cm) = max(3+ 4, 6) = 7
     *          pm = tmp = 6
     *
     *    结束遍历 返回 cm = 7
     * @param nums
     * @return
     */
    public int rob(int[] nums) {
        int preMax = 0;
        int currentMax = 0;
        for (int x : nums){
            int temp = currentMax;
            currentMax = Math.max(preMax + x, currentMax);
            preMax = temp;
        }
        return currentMax;
    }
}
