package com.ming.leetCode;

/**
 * 位 1 的个数
 *  编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。
 *  示例 1：
 *
 * 输入：00000000000000000000000000001011
 * 输出：3
 * 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
 * 示例 2：
 *
 * 输入：00000000000000000000000010000000
 * 输出：1
 * 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
 * 示例 3：
 *
 * 输入：11111111111111111111111111111101
 * 输出：31
 * 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
 * @Author ming
 * @time 2020/2/21 14:54
 */
public class Solution191 {

    /**
     * 方法1 ： 循环和位移动
     * 这个方法比较直接。我们遍历数字的32位。如果某一位是1，将计数器加一。
     * 我们使用 位码来检查数字的第i 位。一开始，掩码m=1.因为1的二进制 是 0000 0000 0000 0000 0000 0000 0000 0001
     * 显然，任何数字跟掩码1 进行逻辑与运算，都可以让我们获得这个数的最低位，检查下一位时，我们要将掩码左移一位
     * 0000 0000 0000 0000 0000 0000 0000 0010
     * 并重复此过程
     *
     * 复杂度分析
     *
     * 时间复杂度：O(1) 。运行时间依赖于数字 n 的位数。由于这题中 n 是一个 32 位数，所以运行时间是 O(1)的。
     *
     * 空间复杂度：O(1)。没有使用额外空间。
     *
     * @param n
     * @return
     */
    public int hammingWeight(int n){
        int count = 0;
        int mask = 1;
        for (int i = 0; i < 32; i++) {
             if ( (n & mask) != 0){
                 count ++;
             }

             mask <<= 1;//左移
        }

        return count;
    }

    /**
     * 方法2 位操作的小技巧
     * 算法：
     *   我们可以把前面的算法进行优化。我们不再检查数字的每一个位。
     *   而是不断把数字最后一个1反转，并把答案加1.
     *   当数字变成0的时候，我们就能知道它没有1的位了，此时返回的答案
     *
     *   这里关键的想法是对于 任意数字n,将n 和n-1 做与运算， 会把最后一个1的位变成0。
     *    为什么？
     *    举例
     *       n :  0000 1111 0000 1111 0000 1111 0000 1100
     *     n-1 :  0000 1111 0000 1111 0000 1111 0000 1011
     *  n&(n-1):  0000 1111 0000 1111 0000 1111 0000 1000
     *  在二进制表示中，数字n中最低位的1 总是对应 n-1的0，
     *  因此，将n和n-1与运算总是能把n中最低位的1 变成0，并保持其他位不变
     *
     *  复杂度分析
     * 时间复杂度：O(1) 。运行时间与 n 中位为 1 的有关。在最坏情况下， n 中所有位都是 1 。对于 32 位整数，运行时间是 O(1) 的。
     * 空间复杂度：O(1) 。没有使用额外空间。
     *
     * @param n
     * @return
     */
    public int hammingWeight2(int n){
        int count = 0;
        while (n != 0){
            count ++;
            n = n & (n -1);
        }
        return count;
    }
}
